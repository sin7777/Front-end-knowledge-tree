# 数组

## 数组拍平

```JS
let array = [1, [2], [3, [4, [5]]]]
//原始方法
function flat() {
  var flatArr = []
  return function flatten(arr) {
    for (let index = 0; index < arr.length; index++) {
      Array.isArray(arr[index])
        ? flatten(arr[index])
        : flatArr.push(arr[index])
    }
    return flatArr
  }
}
console.log(flat()(array))

//ES6
//拍平+去重
Array.from(new Set(array.flat(Infinity)))

//toString
function flat(arr) {
  return arr.toString().split(',').map(val => +val)
}
console.log(flat(array))

//reduce 为数组提供累加器，合并为一个值
//reduce1
const flatten = arr => {
  return arr.reduce((flat, toFlat) => {
    return flat.concat(Array.isArray(toFlat) ? flatten(toFlat) : toFlat);
  }, []);
};
const res = flatten(arr);
//reduce2
let array = [1, [2], [3, [4, [5]]]]
function flat(arr) {
  return arr.reduce((pre, value) => {
    return Array.isArray(value) ? [...pre, ...flat(value)] : [...pre, value]
  }, [])
}

console.log(flat(array))
```

### 数组去重（数组元素的类型多样）

```JS
//ES6
function dedupe(array) {
  return Array.from(new Set(array));
}
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]

//indexOf 方法1
//数组的indexOf()方法可返回某个指定的元素在数组中首次出现的位置。重新开一个数组
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    let res = []
    for (let i = 0; i < arr.length; i++) {
        if (res.indexOf(arr[i]) === -1) {
            res.push(arr[i])
        }
    }
    return res
}

//indexOf 方法2
//利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    return Array.prototype.filter.call(arr, function(item, index){
        return arr.indexOf(item) === index;
    });
}

```

## 数组拼接
