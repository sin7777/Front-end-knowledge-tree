# 字节跳动面经

## 一面2019.07.15

> 这次面试比较头大，自我感觉上没有什么题目答得比较好

### 改变this指向的方法

call() apply() bind()

### 模拟bind实现

我觉得还是比较难，先马上[文章链接](https://github.com/mqyqingfeng/Blog/issues/12)

模拟实现上要考虑的是入参和返回值，bind的入参以及返回值分别是什么？

```JS
Function.prototype.bind2 = function (context) {
    //判断是否为函数
    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }
    //除了context之外还有其他的入参
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

### 判断下列输出

```JS
function bind(obj){
    let self = this
    return function(){
        return self.call(obj)
    }
}
function a(){
    console.log(this.name)
}
let b = {
    name: 1
}
let b2 = {
    name: 10
}

let c = a.bind(b)
c()  //undefined
let d = a.bind(b2)
d() //10
```

### 构造函数的了解

```JS
let a = new B()

let B = function(){
    return 1
}
//为什么返回的是函数，而不是1
```

### 深度遍历实现

### 广度遍历非递归实现

### 环形链表的判断

### 反转链表

### HTTP缓存机制、优先级是什么

### 实现浮点数的精确计算

浮点数出现不准确的原因：

* 浮点数表示成为二进制会产生无限小数
* JS存储浮点数采用64的精度（1位表示正负、11位表示指数，52位表示精度）
* 用有限的存储位数表示无限的小数，会产生精度问题

解决方法：

* toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。
* toFixed 是小数点后指定位数取整，从小数点开始数起。

```JS
0.10000000000000000555.toPrecision(16)   // 返回 0.1000000000000000，
//toFixed 来做四舍五入，但一定要知道它是有 Bug 的。
1.005.toFixed(2)  //返回1.00
//原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去
```

准确计算的方法：

基本思想都是转换成为证书，再进行相应的加减乘除

```JS
/**
 * 精确加法，转成整数之后再进行加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const maxLen = Math.max(num1Digits, num2Digits)
  const baseNum = Math.pow(10, maxLen);
  return Number(((num1 * baseNum + num2 * baseNum) / baseNum).toFixed(maxLen));
}
/**
 * 精确减法，a-b = a + (-b)
 */
 function sub(num1, num2) = add(num1, -num2)
 /**
 * 精确乘法=
 */
 function mul(num1, num2) {
    const digits = (num1.toString().split('.')[1] || '').length + (num2.toString().split('.')[1] || '').length;
    return Number(num1.toString().replace(".", "")) * Number(num2.toString().replace(".", "")) / Math.pow(10, digits);
},
/**
 * 精确除法，a-b = a + (-b)
 */
  function div(num1, num2) {
    const digits = (num1.toString().split('.')[1] || '').length - (num2.toString().split('.')[1] || '').length;
    return Number(num1.toString().replace(".", "")) / Number(num2.toString().replace(".", "")) / Math.pow(10, digits);
},
```

### 实现异步任务调度器

### 数组去重（数组元素的类型多样）
