# 有赞一面

## 文件的权限管理

## 线程和进程

线程和进程的概念

浏览器的进程和线程

为什么浏览器要设计成多进程的？

## JS 单线程

JS 单线程怎么实现异步的

webworker 和 JS 线程是怎么通信的？

## JS 的数据类型

有哪几种

sybmol 的作用是什么？

区分数组、函数、普通对象的方法（尽可能多）

## HTTP 常见状态码

## 304

Etag是根据什么生成的？

## 为什么要做不同域的请求合并

TCP 重新连接？

为什么在 HTTP1.1 要考虑不同域的请求合并的优化，在之后的协议版本当中不需要？

我不是非常清楚，讲了 HTTP1.1 的 keep-alive，HTTP2 的多路复用以及服务端推送。

多路复用的 stream 流的唯一标识是怎样的？也就是报文格式是怎样的？

## 为什么要三次握手

## Vue 问什么 Data 要是一个函数

## v-model 有什么替代方案

？？？

## 手撕代码

```JS
// 实现一个下划线转驼峰的工具方法
// 示例返回
// {
//     renderTime: 1234,
//     template: 'aaa',
//     actionList: {
//         itemAction: 1,
//         itemText: 'bbb'
//     }
// }

const testObj = {
    'render_time': 1234,
    'template': 'aaa',
    'action_list': {
        'item_action': 1,
        'item_text': 'bbb'
    }
};

function mapKeysToCamelCase(obj) {
    let keys = Object.keys(obj)
    let resultObj = {}
    keys.map((item) => {
        let changeName = changeCase(item)
        let flag = Object.prototype.toString.call(obj[item]) === "[object Object]"
        if(flag){
            resultObj[changeName] = mapKeysToCamelCase(obj[item])
        }else{
            resultObj[changeName] = obj[item]
        }
    })
    return resultObj
}

function changeCase(str){
    let tmp = str.split("_")
    let first = tmp.shift()
    return tmp.reduce((result, item) =>{
        let a = item.split("")
        a[0] = a[0].toLocaleUpperCase()
        return result.concat(a.join(""))
    },first)
}

let result = mapKeysToCamelCase(testObj)
console.log(result)
```
