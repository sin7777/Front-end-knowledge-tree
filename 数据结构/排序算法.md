# 排序算法

> [详细文章](https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md)
>
> [动态演示](https://www.cnblogs.com/onepixel/p/7674659.html)

目录

* [冒泡排序](#冒泡排序（稳定）)
* [选择排序](#选择排序（不稳定）)
* [插入排序](#插入排序（稳定）)
* [快速排序](#快速排序（不稳定）)
* [堆排序](#堆排序（不稳定）)

## 冒泡排序（稳定）

时间复杂度

* 平均复杂度：O($n^2$)
* 最好：O($n$)
* 最坏：O($n^2$)
  
空间复杂度：O($1$)

```js
function bubbleSort(arr){
    let len = arr.length
    let tmp
    for(let i = 0; i < len; i++){
        for(let j = i; j < len; j++){
            if (arr[j] > arr[j+1]) {
              tmp = arr[j + 1]
              arr[j + 1] = arr[j]
              arr[j] = tmp
            }
        }
    }
    return arr
}
```

## 选择排序（不稳定）

时间复杂度

* 平均复杂度：O($n^2$)
* 最好：O($n^2$)
* 最坏：O($n^2$)
  
空间复杂度：O($1$)

```js
function selectionSort(arr){
    let len = arr.length
    let minIndex, tmp
    for(let i = 0; i < len; i++){
        minIndex = i
        for(let j = i + 1; j < len; j++){
            if(arr[j] < arr[minIndex]){
                minIndex = j
            }
        }
        if(minIndex !== i){
            tmp = arr[minIndex]
            arr[minIndex] = arr[i]
            arr[i] = arr[minIndex]
        }
    }
    return arr
}
```

## 插入排序（稳定）

时间复杂度

* 平均复杂度：O($n^2$)
* 最好：O($n$)
* 最坏：O($n^2$)
  
空间复杂度：O($1$)

```JS
function insertionSort(arr){
    let len = arr.length
    let current, preIndex
    for(let i = 1; i < len; i++){
        current = arr[i]
        preIndex = i -1
        while(preIndex >= 0 && arr[preIndex] > current){
            arr[preIndex + 1] = arr[preIndex]
            preIndex--
        }
        arr[preIndex + 1] = current
    }
    return arr
}
```

## 快速排序（不稳定）

时间复杂度

* 平均复杂度：O($nlog_2n$)
* 最好：O($nlog_2n$)
* 最坏：O($n^2$)
  
空间复杂度：O($nlog_2n$)

```JS
function sort(arr){
    quickSort(arr, 0, arr.length)
}
function quickSort(arr, left, right){
    let partitionIndex;
    if(left < right){
        partitionIndex = partition(arr,left,right)
        quickSort(arr, left, partitionIndex-1)
        quickSort(arr, partitionIndex+1, right)
    }
    return arr
}
function partition(arr, left, right){
    let pivot = left,
        index = pivot + 1;
    for(let i = index; i < right; i++){
        if(arr[i] < arr[pivot]){
            swap(arr, i, index)
            index++
        }
    }
    swap(arr, pivot, index-1)
    return index-1
}
function swap(arr, i, j){
    let tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
}

```

## 堆排序（不稳定）

* 平均复杂度：O($nlog_2n$)
* 最好：O($nlog_2n$)
* 最坏：O($nlog_2n$)
  
空间复杂度：O($1$)

堆排序（升序）过程：

* 构建大顶堆
* 堆顶元素与无序列表的一个元素交换
* 调整大顶堆，直到有序列表的 length = n - 1

```JS
function heapSort(arr){
    buildMaxHeap(arr)

    for(let i = arr.length - 1; i > 0; i--){
        swap(arr, i, 0)
        heapify(arr, 0, i)
    }
    return arr
}
function buildMaxHeap(arr){
    let len = arr.length
    for(let i = Math.floor(len/2 - 1); i > 0; i--){
        heapify(arr, i, len)
    }
}
function heapify(arr, i, length){
    let current = i,
        left = 2 * i + 1,
        right = 2 * i + 2;
    if(right < lenght && arr[right] > arr[current]){
        current = right
    }
    if(left < length && arr[left] > arr[current]){
        current = left
    }
    if(current !== i){
        swap(arr, current, i)
        heapify(arr, current, length)
    }
}
function swap(arr, i, j){
    let tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```

## 希尔排序

## 归并排序

## 计数排序

## 桶排序

## 基数排序
