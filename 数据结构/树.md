# 树的遍历

JS中树的结构是以对象的形式进行存储的，所以相对来说比较好写一点

```JS
var tree = {
  node: 6,
  left: {
    node: 5,
    left: {
      node: 4
    },
    right: {
      node: 3
    }
  },
  right: {
    node: 2,
    right: {
      node: 1
    }
  }
}
```

## 深度优先

### 先序遍历

1. 若二叉树为空，则算法结束，否则：
2. 访问根结点；
3. 前序遍历根结点的左子树；
4. 前序遍历根结点的右子树。

#### 递归实现

```JS
let result = []
function dfs(nodes){
    if(nodes.node){
        result.push(nodes.node)
        nodes.left && dfs(nodes.left)
        nodes.right && dfs(nodes.right)
    }
}
dfs(tree)
console.log(result)
```

#### 非递归实现

1. 初始化一个栈，将根节点压入栈中
2. 当栈非空时，循环执行3，4步，否则执行结束
3. 出队列取得一个节点、访问改节点
4. 若该节点的右子树非空，将该节点的右子树入栈，若该节点的左子树非空，将该节点的左子树入栈

```JS
function dfs(nodes){
    let result = []
    let stack = []
    stack.push(nodes)
    while(stack.length){
        let item = stack.pop()
        result.push(item.node)
        item.right && stack.push(item.right)  //先将右边压入栈，出栈的顺序是先左后右
        item.left && stack.push(item.left)
    }
    return result
}
console.log(dfs(tree))
```


## 广度优先
