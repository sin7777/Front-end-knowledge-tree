# React 的发展过程

## 2013年5月底正式开源

## Earlier than 0.14.x (2015年)

ES6没有普及的时候，创建组件使用的是 React.createClass，不需要手动绑定 `this`，原因其实是在旧版本的reactClass这个对象里面，在初始化的时候，会遍历所有的传入到createClass的key value，默认的内置lifCycle都会走默认的行为，但是那些所有不是lifeCycle的，都统统会经过一个判断循环。

## 2016年6月发布redux

## V16.8.0

### Hook

Hook 解决了什么问题？

* 组件之间复用状态逻辑很难，嵌套地狱
* 复杂组件变得难以理解，生命周期
  * class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。
* class会带来的问题（this）

Hook 是一种复用状态逻辑的方式，它不复用 state 本身。

```JS
//数组解构的语法
const [fruit, setFruit] = useState('banana');

//等价于
var fruitStateVariable = useState('banana'); // 返回一个有两个元素的数组
  var fruit = fruitStateVariable[0]; // 数组里的第一个值
  var setFruit = fruitStateVariable[1]; // 数组里的第二个值
```

useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合

useEffect Hook 使用了 JavaScript 的闭包机制

递给 useEffect 的函数在每次渲染中都会有所不同

大多数情况下，effect 不需要同步地执行。

性能优化：如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可：

Hook需要按照顺序编写，是队列？

#### 怎样共享状态逻辑

* render props
* 高阶组件
* Hook

在两个组件中使用相同的 Hook 会共享 state 吗？不会。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和 effect 都是完全隔离的。

```JS
// 改写 Antd 的 modol 组件
const Modal = () => {
  const [visible, changeVisible] = useState(false);
  return (
    <div>
      <Button type="primary" onClick={() => changeVisible(true)}>
        open
      </Button>
      <Modal
        title="Basic Modal"
        visible={visible}
        onOk={() => changeVisible(false)}
        onCancel={() => changeVisible(false)}
      >
        <p>this is a modal</p>
      </Modal>
    </div>
  );
};
```
