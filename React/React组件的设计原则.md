# React组件的设计原则

## [单一职责](https://juejin.im/post/5d4acb28e51d45620771f082)

多重职责会使得组件非常脆弱，也会带来很多的副作用，出于某种原因更改组件会无意中影响同一组件实现的其它职责。所以在组件的设计当中推崇“单一职责”

两种方式实现

* 功能拆分
* HOC
  * 属性代理
  * 渲染劫持

## [封装](https://juejin.im/post/5d4c329e51882511ed7c203f)

一个封装组件提供 props 控制其行为而不是暴露其内部结构。

耦合是决定组件之间依赖程度的系统特性。根据组件的依赖程度，可区分两种耦合类型：

* 当应用程序组件对其他组件知之甚少或一无所知时，就会发生**松耦合**。
* 当应用程序组件知道彼此的许多详细信息时，就会发生**紧耦合**。

松耦合是我们设计组件之间关系的目标。

### 信息隐藏

* 封装良好的组件隐藏其内部结构，并提供一组属性来控制其行为。
* 隐藏内部结构是必要的。其他组件没必要知道或也不依赖组件的内部结构或实现细节。
* React 组件可能是函数组件或类组件、定义实例方法、设置 ref、拥有 state 或使用生命周期方法。这些实现细节被封装在组件内部，其他组件不应该知道这些细节。
* 隐藏内部结构的组件彼此之间的依赖性较小，而降低依赖度会带来松耦合的好处。

### 通信

细节隐藏是隔离组件的关键。此时，你需要一种组件通信的方法：**props**。

* 建议 prop 的类型为基本数据（例如，string 、 number 、boolean）：
`<Message text="Hello world!" modal={false} />;`
* 必要时，使用复杂的数据结构，如对象或数组：
`<MoviesList items={['Batman Begins', 'Blade Runner']} />`
  prop 可以是一个事件处理函数和异步函数：
`<input type="text" onChange={handleChange} />`
* prop 甚至可以是一个组件构造函数。组件可以处理其他组件的实例化：

```JSX
function If({ component: Component, condition }) {
    return condition ? <Component /> : null;
}
<If condition={false} component={LazyComponent} />
```

为了避免破坏封装，请注意通过 props 传递的内容。给子组件设置 props 的父组件不应该暴露其内部结构的任何细节。例如，使用 props 传输整个组件实例或 refs 都是一个不好的做法。

访问全局变量同样也会对封装产生负面影响。

## 组合和复用

单一责任原则描述了如何将需求拆分为组件，封装描述了如何组织这些组件，组合描述了如何将整个系统粘合在一起。

组合的好处

* 可以利用好单一职责
* 使组件可重用
* 使组件更加灵活和高效

复用的好处

* 自己编写应用内的复用
* 复用第三方库

## 纯组件

## 其他
