# 跨域相关

## 同源政策

只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。

跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，**只是结果被浏览器拦截了**

* DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。
* XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。

跨域限制的原因

安全性——CSRF攻击

## 跨域的实现方式

### CORS

CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信

a. 对于客户端，我们还是正常使用xhr对象发送ajax请求。

唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true;

b. 对于服务器端，需要在 response header中设置如下两个字段:

```JS
Access-Control-Allow-Origin: http://www.yourhost.com
Access-Control-Allow-Credentials:true
```

### jsonp

浏览器对script标签src属性、link标签ref属性和img标签src属性没有同源策略限制，利用这个“漏洞”就可以很好的解决跨域请求

img link iframe 等元素都可以发送跨域请求

通过动态创建script标签,然后利用src属性进行跨域，jsonp 是通过插入一个 script 标签，利用 script 可以跨域请求来实现。

为什么只能发get不能发post？src请求是一个get请求

```JS
//创建script发送请求
//请求返回执行cb函数，并且删除创建的script
//类似于$ajax中的jsonp
function jsonp(url,params,cb){
    return new Promimse((resolve,reject)=>{
        window[cb] = function(data){
            resolve(data);
            document.body.removeChild(script);
        }
        params={...params,cb},
        let arrs=[];
        for(let key in params){
            arrs.push(`${key}=${params[key]}`)
        }
        let script = document.createElement('script');
        script.src= url + '?'+ arrs.join('&');
        document.body.appendChild(script);
    })
}
jsonp({
    url:'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',
    params:{wd:%E8%B7%A8%E5%9F%9F},
    cb:'show'}).then(data=>{
        console.log(data)
    })
```

> CORS与JSONP的使用目的相同，但是比JSONP更强大。
>
> JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

### postMessage

配合使用iframe，需要兼容IE6、7、8、9

### document.domain

仅限于同一域名下的子域

### websocket

需要后台配合修改协议，不兼容，需要使用socket.io

### proxy

使用代理去避开跨域请求，需要修改nginx、apache等的配置
