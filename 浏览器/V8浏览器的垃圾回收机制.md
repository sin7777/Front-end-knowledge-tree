# V8 浏览器的垃圾回收机制♻️

> V8 的垃圾回收机制只要基于分布式垃圾回收机制，分布式是指将内存分为 `新生代` 和 `老生代` 两种，分别采用不同的算法进行回收。
>
> [参考](https://juejin.im/post/5ad3f1156fb9a028b86e78be)

新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代）

![内存组织形式](https://user-gold-cdn.xitu.io/2018/4/14/162c3526b85b16a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。

新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）

## 新生代主要使用 Scavenge 进行管理，主要实现是 Cheney 算法

将内存平均分为两块，使用空间叫From，闲置空间叫To

新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配。

> [👉详情图片理解过程请参考👈](https://juejin.im/post/5ad3f1156fb9a028b86e78be)

### 什么时候新生代对象会升级成为老生代对象

两个条件

* 如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中
* 当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中（如果占比过高，会影响后续的内存分配）

## 老生代主要采用 Mark-Sweep 和 Mark-Compact 算法，一个是标记清除，一个是标记整理

### 标记清除：Mark-Sweep

分为标记和清除两个阶段

Mark-Sweep在标记阶段遍历堆内存中的所有对象，并**标记活着的对象**，在随后的清除阶段，只**清除没有被标记的对象**。

Mark-Sweep在垃圾回收后会产生碎片内存

### 标记整理：Mark-Compact

为了解决Mark-Sweep的内存碎片问题，也分为标记和清除，但在清除之前会进行整理。

Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些
